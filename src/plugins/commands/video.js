const fs = require('fs');
const path = require('path');
const axios = require('axios');
const { ThreadType } = require('zca-js');

// C·∫•u h√¨nh chung
const CONFIG = {
  maxRetries: 10,
  checkTimeout: 3000,
  retryDelay: 1000,
  fallbackToDownload: true, // Fallback v·ªÅ c√°ch c≈© n·∫øu sendVideo th·∫•t b·∫°i
};

// C√°c h√†m utility
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const checkVideoUrl = async (url) => {
  try {
    await Promise.race([
      axios.head(url, {
        timeout: CONFIG.checkTimeout,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      }),
      delay(CONFIG.checkTimeout).then(() => {
        throw new Error("Timeout khi ki·ªÉm tra URL -> Chuy·ªÉn qua link kh√°c");
      }),
    ]);
    return true;
  } catch (error) {
    return false;
  }
};

// H√†m l·∫•y th√¥ng tin video t·ª´ URL
const getVideoInfo = async (videoUrl) => {
  try {
    const response = await axios.head(videoUrl, {
      timeout: CONFIG.checkTimeout,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });

    const contentType = response.headers['content-type'] || '';
    const contentLength = parseInt(response.headers['content-length'] || '0');

    return {
      isVideo: contentType.includes('video/'),
      fileSize: contentLength,
      contentType
    };
  } catch (error) {
    return { isVideo: false, fileSize: 0, contentType: '' };
  }
};

// H√†m g·ª≠i video tr·ª±c ti·∫øp qua URL (s·ª≠ d·ª•ng ZCA-JS sendVideo API)
async function sendVideoDirectly(api, event, videoUrl, videoType) {
  try {
    console.log(`üé¨ ƒêang g·ª≠i video tr·ª±c ti·∫øp: ${videoUrl}`);

    // L·∫•y th√¥ng tin video
    const videoInfo = await getVideoInfo(videoUrl);
    if (!videoInfo.isVideo) {
      console.log(`‚ùå URL kh√¥ng ph·∫£i video h·ª£p l·ªá: ${videoUrl}`);
      return { success: false, shouldRemove: true };
    }

    // T·∫°o thumbnail URL (c√≥ th·ªÉ d√πng c√πng URL ho·∫∑c t·∫°o thumbnail ri√™ng)
    const thumbnailUrl = videoUrl; // T·∫°m th·ªùi d√πng c√πng URL

    // C·∫•u h√¨nh video options
    const videoOptions = {
      msg: `üé¨ Video ${videoType} ng·∫´u nhi√™n`,
      videoUrl: videoUrl,
      thumbnailUrl: thumbnailUrl,
      duration: 30000, // 30 gi√¢y (m·∫∑c ƒë·ªãnh)
      width: 1280,
      height: 720,
      ttl: 300000 // Tin nh·∫Øn t·ª± x√≥a sau 5 ph√∫t
    };

    // G·ª≠i video s·ª≠ d·ª•ng ZCA-JS API
    const result = await api.sendVideo(videoOptions, event.threadId, event.type);

    if (result && result.msgId) {
      console.log(`‚úÖ ƒê√£ g·ª≠i video th√†nh c√¥ng qua URL: ${videoType}`);
      return { success: true, shouldRemove: false };
    } else {
      console.log(`‚ùå Kh√¥ng th·ªÉ g·ª≠i video qua URL: ${videoUrl}`);
      return { success: false, shouldRemove: false };
    }

  } catch (error) {
    console.error(`‚ùå L·ªói khi g·ª≠i video tr·ª±c ti·∫øp: ${error.message}`);

    // Ph√¢n lo·∫°i l·ªói ƒë·ªÉ quy·∫øt ƒë·ªãnh c√≥ x√≥a link kh√¥ng
    const shouldRemove =
      error.message.includes('404') ||
      error.message.includes('403') ||
      error.message.includes('Invalid URL') ||
      error.message.includes('Unable to get video content');

    return { success: false, shouldRemove };
  }
}

// H√†m t·∫£i video v√† t·∫°o file t·∫°m (fallback method)
async function downloadVideo(videoUrl) {
  try {
    const response = await axios.get(videoUrl, {
      responseType: 'arraybuffer',
      timeout: 30000,  // 30 gi√¢y timeout cho video
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });

    const tempDir = path.join(__dirname, 'temp');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }

    const fileName = `video_${Date.now()}.mp4`;
    const filePath = path.join(tempDir, fileName);

    fs.writeFileSync(filePath, response.data);
    return { success: true, filePath, error: null, shouldRemove: false };
  } catch (error) {
    console.error('L·ªói khi t·∫£i video:', error.message);

    // Ph√¢n lo·∫°i l·ªói ƒë·ªÉ quy·∫øt ƒë·ªãnh c√≥ x√≥a link kh√¥ng
    const shouldRemove =
      error.response?.status === 404 ||           // Not Found
      error.response?.status === 403 ||           // Forbidden (link ch·∫øt)
      error.response?.status === 410 ||           // Gone
      error.code === 'ENOTFOUND' ||               // Domain kh√¥ng t·ªìn t·∫°i
      error.message.includes('Invalid URL');      // URL kh√¥ng h·ª£p l·ªá

    return {
      success: false,
      filePath: null,
      error: error.message,
      shouldRemove
    };
  }
}

// X·ª≠ l√Ω video t·ª´ file - ∆Øu ti√™n g·ª≠i tr·ª±c ti·∫øp, fallback v·ªÅ t·∫£i local
async function handleVideoFromFile(api, event, filePath, videoType) {
  let videoLinks = fs.readFileSync(filePath, "utf-8").split("\n").filter(Boolean);
  let isDieLink = false;

  while (videoLinks.length > 0) {
    const randomIndex = Math.floor(Math.random() * videoLinks.length);
    const videoUrl = videoLinks[randomIndex].trim();

    // Ki·ªÉm tra URL c√≥ h·ª£p l·ªá kh√¥ng
    const isValid = await checkVideoUrl(videoUrl);

    if (isValid) {
      try {
        // Ph∆∞∆°ng ph√°p 1: Th·ª≠ g·ª≠i video tr·ª±c ti·∫øp qua URL (ZCA-JS sendVideo API)
        console.log(`üöÄ Th·ª≠ g·ª≠i video tr·ª±c ti·∫øp: ${videoUrl}`);
        const directResult = await sendVideoDirectly(api, event, videoUrl, videoType);

        if (directResult.success) {
          // G·ª≠i th√†nh c√¥ng qua URL - c·∫≠p nh·∫≠t file n·∫øu c√≥ link ch·∫øt ƒë√£ b·ªã x√≥a
          if (isDieLink) {
            fs.writeFileSync(filePath, videoLinks.join('\n'));
            console.log(`üìù ƒê√£ c·∫≠p nh·∫≠t file, x√≥a c√°c link ch·∫øt`);
          }
          return true;
        }

        // N·∫øu link ch·∫øt th√¨ x√≥a v√† th·ª≠ link kh√°c
        if (directResult.shouldRemove) {
          console.log(`üóëÔ∏è X√≥a link ch·∫øt: ${videoUrl}`);
          videoLinks.splice(randomIndex, 1);
          isDieLink = true;
          continue;
        }

        // Ph∆∞∆°ng ph√°p 2: Fallback - T·∫£i video v·ªÅ local n·∫øu c·∫•u h√¨nh cho ph√©p
        if (CONFIG.fallbackToDownload) {
          console.log(`‚¨áÔ∏è Fallback: T·∫£i video v·ªÅ local: ${videoUrl}`);
          const downloadResult = await downloadVideo(videoUrl);

          if (!downloadResult.success) {
            console.log(`‚ùå Kh√¥ng th·ªÉ t·∫£i video: ${videoUrl} - L·ªói: ${downloadResult.error}`);

            // Ch·ªâ x√≥a link n·∫øu l√† l·ªói th·ª±c s·ª± v·ªÅ link ch·∫øt
            if (downloadResult.shouldRemove) {
              videoLinks.splice(randomIndex, 1);
              isDieLink = true;
              console.log(`üóëÔ∏è ƒê√£ x√≥a link ch·∫øt: ${videoUrl}`);
            }
            continue;
          }

          const videoPath = downloadResult.filePath;

          // G·ª≠i video ƒë√£ t·∫£i v·ªÅ
          await api.sendMessage({
            msg: `üé¨ Video ${videoType} ng·∫´u nhi√™n`,
            attachments: [videoPath],
            ttl: 300000  // Tin nh·∫Øn t·ª± x√≥a sau 5 ph√∫t
          }, event.threadId, event.type);

          console.log(`‚úÖ ƒê√£ g·ª≠i video th√†nh c√¥ng (fallback): ${videoType}`);

          // G·ª≠i th√†nh c√¥ng - c·∫≠p nh·∫≠t file n·∫øu c√≥ link ch·∫øt ƒë√£ b·ªã x√≥a
          if (isDieLink) {
            fs.writeFileSync(filePath, videoLinks.join('\n'));
            console.log(`üìù ƒê√£ c·∫≠p nh·∫≠t file, x√≥a c√°c link ch·∫øt`);
          }

          // X√≥a file t·∫°m sau khi g·ª≠i
          setTimeout(() => {
            try {
              if (fs.existsSync(videoPath)) {
                fs.unlinkSync(videoPath);
                console.log(`üóëÔ∏è ƒê√£ x√≥a file t·∫°m: ${path.basename(videoPath)}`);
              }
            } catch (error) {
              console.error('L·ªói khi x√≥a file t·∫°m:', error.message);
            }
          }, 5000);

          return true;
        } else {
          console.log(`‚ùå Kh√¥ng th·ªÉ g·ª≠i video v√† fallback b·ªã t·∫Øt: ${videoUrl}`);
          continue;
        }

      } catch (error) {
        console.error("‚ùå L·ªói khi x·ª≠ l√Ω video:", error);
        continue;
      }
    } else {
      console.log(`‚ùå URL kh√¥ng h·ª£p l·ªá, ƒë√£ x√≥a: ${videoUrl}`);
      videoLinks.splice(randomIndex, 1);
      isDieLink = true;
    }
  }

  console.log(`‚ùå Kh√¥ng c√≤n video h·ª£p l·ªá trong file ${path.basename(filePath)}`);
  return false;
}

module.exports.config = {
  name: "video",
  version: "3.0.0",
  role: 0,
  author: "Assistant",
  description: "G·ª≠i video ng·∫´u nhi√™n t·ª´ th∆∞ m·ª•c video. ∆Øu ti√™n g·ª≠i tr·ª±c ti·∫øp qua URL, fallback v·ªÅ t·∫£i local. S·ª≠ d·ª•ng 'video on/off' ƒë·ªÉ b·∫≠t/t·∫Øt",
  category: "Gi·∫£i tr√≠",
  usage: "video [on/off] [anime/cosplay/girl/sex/sexy]",
  cooldowns: 5
};

// ƒê∆∞·ªùng d·∫´n ƒë·∫øn th∆∞ m·ª•c ch·ª©a c√°c file txt
const videoPath = path.join(__dirname, '../../../assets/videos');

// Danh s√°ch c√°c lo·∫°i video c√≥ s·∫µn
const videoTypes = ['anime', 'cosplay', 'girl', 'sex', 'sexy'];

// Mapping file names
const fileMapping = {
  'anime': 'vdanime.txt',
  'cosplay': 'vdcos.txt',
  'girl': 'vdgirl.txt',
  'sex': 'vdsex.txt',
  'sexy': 'vdsexy.txt'
};





module.exports.run = async function({ api, event, args, Threads }) {
  const { threadId, type } = event;
  const senderID = event.data?.uidFrom || event.senderID;

  try {
    // L·∫•y d·ªØ li·ªáu nh√≥m
    const threadData = await Threads.getData(threadId);
    let groupData = threadData.data || {};

    // X·ª≠ l√Ω l·ªánh on/off
    if (args[0] && (args[0].toLowerCase() === 'on' || args[0].toLowerCase() === 'off')) {
      const action = args[0].toLowerCase();

      // Ki·ªÉm tra quy·ªÅn admin ho·∫∑c support (convert to string ƒë·ªÉ ƒë·∫£m b·∫£o match)
      const senderIDStr = String(senderID);
      const isBotAdmin = global.users?.admin?.includes(senderIDStr);
      const isSupport = global.users?.support?.includes(senderIDStr);

      if (!isBotAdmin && !isSupport) {
        return api.sendMessage({
          msg: 'üö´ Ch·ªâ admin ho·∫∑c support bot m·ªõi c√≥ th·ªÉ b·∫≠t/t·∫Øt ch·ª©c nƒÉng video!',
          ttl: 30000  // T·ª± x√≥a sau 30 gi√¢y
        }, threadId, type);
      }

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i video
      groupData.video_enabled = (action === 'on');

      // L∆∞u v√†o database
      await Threads.setData(threadId, groupData);

      const statusText = action === 'on' ? 'b·∫≠t' : 't·∫Øt';
      return api.sendMessage({
        msg: `‚úÖ ƒê√£ ${statusText} ch·ª©c nƒÉng video cho nh√≥m n√†y!`,
        ttl: 30000  // T·ª± x√≥a sau 30 gi√¢y
      }, threadId, type);
    }

    // Ki·ªÉm tra xem ch·ª©c nƒÉng c√≥ ƒë∆∞·ª£c b·∫≠t kh√¥ng (m·∫∑c ƒë·ªãnh l√† t·∫Øt)
    if (groupData.video_enabled !== true) {
      return api.sendMessage({
        msg: '‚ùå Ch·ª©c nƒÉng video ƒëang t·∫Øt!\n\n' +
             'üí° S·ª≠ d·ª•ng "video on" ƒë·ªÉ b·∫≠t ch·ª©c nƒÉng\n' +
             'üí° S·ª≠ d·ª•ng "video off" ƒë·ªÉ t·∫Øt ch·ª©c nƒÉng',
        ttl: 30000  // T·ª± x√≥a sau 30 gi√¢y
      }, threadId, type);
    }

    // L·∫•y lo·∫°i video t·ª´ args (n·∫øu c√≥)
    const requestedType = args[0] ? args[0].toLowerCase() : null;

    // Ki·ªÉm tra lo·∫°i video c√≥ h·ª£p l·ªá kh√¥ng
    if (requestedType && !videoTypes.includes(requestedType)) {
      return api.sendMessage({
        msg: `‚ùå Lo·∫°i video kh√¥ng h·ª£p l·ªá!\n\n` +
             `üìã C√°c lo·∫°i c√≥ s·∫µn: ${videoTypes.join(', ')}\n` +
             `üí° S·ª≠ d·ª•ng: video [${videoTypes.join('|')}]`,
        ttl: 30000  // T·ª± x√≥a sau 30 gi√¢y
      }, threadId, type);
    }

    // L·∫•y video ng·∫´u nhi√™n v√† x·ª≠ l√Ω theo logic m·ªõi
    const selectedType = requestedType || videoTypes[Math.floor(Math.random() * videoTypes.length)];
    const fileName = fileMapping[selectedType];
    const filePath = path.join(videoPath, fileName);

    if (!fs.existsSync(filePath)) {
      return api.sendMessage({
        msg: '‚ùå Kh√¥ng t√¨m th·∫•y file video!',
        ttl: 20000
      }, threadId, type);
    }

    // S·ª≠ d·ª•ng h√†m x·ª≠ l√Ω video m·ªõi
    const success = await handleVideoFromFile(api, event, filePath, selectedType);

    if (!success) {
      return api.sendMessage({
        msg: '‚ùå Kh√¥ng th·ªÉ g·ª≠i video. Vui l√≤ng th·ª≠ l·∫°i sau!',
        ttl: 20000  // T·ª± x√≥a sau 20 gi√¢y
      }, threadId, type);
    }

  } catch (error) {
    console.error('L·ªói trong command video:', error);
    api.sendMessage({
      msg: '‚ùå C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω l·ªánh!',
      ttl: 20000  // T·ª± x√≥a sau 20 gi√¢y
    }, threadId, type);
  }
};
